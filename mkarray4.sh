#!/bin/bash

function usage { echo "Usage: ./mkarray4.sh dirname" ; exit ; }

# This script reads the first three trigger
# jpegs generated by the camera, compares them,
# then outputs raw diff data for a perl
# script to decide whether or not to filter
# this video snippet.  

# The perl script is called
# sortvdata.pl.  It takes the output of this
# script as stdin and processes it.

BASE="/home/mea/cams" ;
C6="$BASE/camera6" ;
LOGDIR="$BASE/logs" ;
mydate=$( date +%Y%m%d ) ;
myhour=$( date +%H%M ) ;
#LOG="$LOGDIR/mkarray.log" ;
LOG="$C6/mkarray.log" ;
#LOG="$BASE/cron.log" ;
LOGTEXT="$mydate $myhour mkarray4.sh" ;

if [ ! -d $LOGDIR ] ; then echo "no $LOGDIR" ; exit ; fi
if [ ! -d $C6 ] ; then echo "no $C6" ; exit ; fi
ADIR="$BASE/camera6/arrays" ;  # array directory
NADIR="/mnt/tmpfs" ; 
if [ ! -d $NADIR ] ; then echo "$LOGTEXT no NADIR $NADIR" ; exit ; fi
filetime=$(date +%H%M%S) ;
debug=0 ; # 1 = debug mode

action="none" ;

CORRUPT="$BASE/camera6/corrupt.sh" ; # the executable
if [ -e $CORRUPT ] ; then mv $CORRUPT /tmp/dump/corrupt-${filetime} ; fi
touch $CORRUPT ; chmod +x $CORRUPT ;

SHOWDATA="$C6/bin/showdata.sh" ; # showdata script
if [ ! -x $SHOWDATA ] ; then echo "$LOGTEXT mkarray4.sh showdata script $SHOWDATA missing" >> $LOG ; exit ; fi

# we're dividing snapshots into a 10x10 grid of zones to be compared
# so the section resolution is 1/10th horizontal and vertical.
# the default value below is for 1280X720 resolution
SECTION_RES="128x72" ; # this is default 1280x720

#CMPTYPE="MAE" ; # MAE is default compare type

# for moving snippets flagged as corrupt/missing data
# it's not a good idea to remove files in a script like this
# so they get sent here to be dealt with later.
CORRUPTDIR=$C6/corrupt ;

if [ ! -d $CORRUPTDIR ] ; then mkdir $CORRUPTDIR ; fi
if [ ! -d $CORRUPTDIR/snaps ] ; then mkdir $CORRUPTDIR/snaps ; fi
if [ ! -d $ADIR ] ; then echo "no $ADIR ... making" ; mkdir $ADIR ; fi
if [ ! -d $ADIR ] ; then echo "no $ADIR ... exiting" ; exit ; fi

# make N, N1, and N2 scratch schmoo storage dirs
# if necessary
if [ ! -d $NADIR/N ] ; then mkdir $NADIR/N ; fi
if [ ! -d $NADIR/N1 ] ; then mkdir $NADIR/N1 ; fi
if [ ! -d $NADIR/N2 ] ; then mkdir $NADIR/N2 ; fi

# if we already processed this sequence number we don't need
# to process it again unless we do then set force
# which is currently commented out
force=0 ; # flag to force overwrite of n1 and n2 data
#if [ $action == "force" ] ; then force=1 ; fi  

if [ -z $1 ] ; then usage ; exit ; fi

dirname="$C6/$1" ; # full path name
LOGTEXT="$mydate $myhour mkarray4.sh" ;
echo "$LOGTEXT processing $1" | tee -a $LOG ;
if [ ! -d $dirname ] ; then echo "$LOGTEXT $dirname does not exist" >> $LOG ; exit ; fi

daydirs=$(ls -ld $dirname/2* | grep ^d | awk '{print $9}' ) ;
if [ -z "$daydirs" ] ; then 
	echo "$LOGTEXT nothing in directory $dirname" | tee -a $LOG ; exit ; 
fi
echo "$LOGTEXT daydirs" | tee -a $LOG  ; 
echo "$daydirs" | tee -a $LOG ; # exit ;

for daydir in $daydirs ; 
do
	echo "$LOGTEXT processing daydir $daydir" | tee -a $LOG  ;
	mp4dir="$daydir" ; # this had better exist
	if [ ! -d $mp4dir ]  ; then echo "$LOGTEXT mp4dir $mp4dir does not exist" ; exit ; fi 
	checkmp4=$(ls $mp4dir | grep "\.mp4$"  ) ; 
	if [ -z "$checkmp4" ] ; then echo "$LOGTEXT no mp4 files in $checkdir" >> $LOG ; continue ; fi
	# check for snap directory
	snapdir="$mp4dir/snaps" ;
	if [ ! -d $snapdir ] ; then 
		echo "$LOGTEXT no snaps dir in $mp4dir ... continuing" | tee -a $LOG ; 
		# without a snaps directory this script cannot
		# filter approaches so continue on to next day
		continue ;
	fi
	checkjpegs=$(ls $snapdir | grep "\.jpg$" ) ; 
	if [ -z "$checkjpegs" ] ; then 
		echo "$LOGTEXT no jpegs in $snapdir ... continueing" | tee -a $LOG ; 
		continue ; 
	fi
	
done

#echo "got here daydirs=$daydirs" ; # exit ; 

# now that integrity check was done let's cycle through
# the directory of days

# the following is a double loop looping through
# $daydirs and mp4 files

# no indentation for readability

for daydir in $daydirs ; # outer loop
do
	SNAPSDIR="$daydir/snaps" ;
	echo "$LOGTEXT processing outer loop daydir $daydir" >> $LOG  ;
	if [ ! -d $SNAPSDIR ] ; then 
		echo "$SNAPSDIR does not exist" ; 
#		rmdir "$dirname/$daydir" ;
		continue ;
	fi

	# daydir verified above to have .mp4 files
	# NOTE: mp4, the filetype is hard coded for now fix this later
	dirwc=$(ls $daydir | grep "\.mp4$" | wc | awk '{print $1}') ;

# the main loop ste

# reminder that $dirname is full path to $C6/new (default sub directory)

# The main loop processes mp4 snapshots using the ImageMagick compare command
# 
# The first three snapshots are called N,N1,N2
# we want to separate approaching cars from everything else that can
# trigger the camera.

# the N snapshot is when the camera triggered, N1 one second later,
# N2 2 seconds later.  The main loop generates N<->N1 differences
# and N1<->N2 differences.

# the difference numbers are processed later.  The main loop just
# generates data from the compare command.  Clear as mud?

mp4dir="$daydir" ;
mp4files=$( ls $mp4dir | grep "\.mp4" ) ;
mycount=0 ; # counter to echo and increment to show job status

#echo "got here mp4files $mp4files" ; exit ;

#---------------------------main loop-------------------------
# mp4 is the only extension supported for now

   for file in $mp4files ;  # inner loop
   do
#	echo "$LOGTEXT processing $file" >> $LOG ; 

	mp4file="$daydir/$file" ;
	# seqnum variable probably redundant but whatever
        seqnum=$(echo $file | sed -e "s/\.mp4//" ) ;
	global_mynum=$seqnum ;
	seqtime=$(echo $seqnum | awk 'BEGIN{FS="_"}{print $2}') ;
	seqdate=$(echo $seqnum | awk 'BEGIN{FS="_"}{print $1}') ;
        myyear=${seqnum:0:4} ;
        mymonth=${seqnum:4:2} ;
        myday=${seqnum:6:2} ;
        mydate=${seqnum:0:8} ;
        myhour=${seqnum:9:2}  ;
        mymin=${seqnum:11:2}  ;
        mysec=${seqnum:13:2}  ;
        myhms=${seqnum:9:6}  ;

	# the start of jpeg numbering comes from the second part of the
	# mp4 sequence number, first part being dateid
	#
	# seqnum = dateid_HHMMSS
	#
	# this must be converted to a number we can add and subtract
	# to which an epoch.
	# epoch is number of seconds since 1/1/1970
	# myepoch is the starting epoch when searching for jpeg snapshots
	# clear as mud?
        myepoch=$( date --date "$mymonth/$myday/$myyear $myhour:$mymin:$mysec"  +%s  ) ;

	# seqtime, the time part of sequence number
	# is 6 digits (hour min sec) and can have leading zeros
	# nozeros takes them out making it a real integer and the code cleaner 
	nozeros=$(echo $seqtime | sed 's/^0*//')

	let mycount=$mycount+1 ;
	echo "$LOGTEXT processing $seqnum count=$mycount" | tee -a $LOG ;

        loop="yes"  ;
        found=0 ; # keeps track of loop below

	# now we have to find the jpegs

	# snapshot .jpg files are started several seconds after
	# the mp4 sequence numbers so we have to find them
	#
	# the below loop will populate the files listed in $myjpegs 
	# they are first three snapshot filenames separated by spaces
	# 
	# once we know the filenames we can process the two transitions
	#
	# N <-> N1 and N1 <-> N2
	#
	# this requires 3 snapshots which we now know where they are located.
	# From these two transitions we can determine an approach
	# in the following loop

	# Reminder: SNAPSDIR="$daydir/snaps" ;
	# daydir is directory of mp4s in a ........./$dateid directory
        while [ $loop == "yes" ] ;
        do
                # reconstruct sequence number
                jseqnum=$( echo $myepoch | awk '{print strftime("%Y%m%d_%H%M%S",$1) }'  ) ;
if [ $debug -eq 1 ] ; then echo "$LOGTEXT jseqnum = $jseqnum" ; continue ; fi

                if [ ! -d $SNAPSDIR ] ; then echo "$LOGTEXT no jpeg repo $SNAPSDIR ... fix this!" ; exit ; fi
                jpgfname="$SNAPSDIR/${jseqnum}.jpg" ;
                if [ -e $jpgfname ] ; then # it's a hit
                        # try and get all three snaps
                        # this is hard coded for now
                        found=0 ;

			# $myjpegs is a string of 3 snapshot jpeg files
                        myjpegs=$jpgfname ;

			# I hate dealing with arrays in bash!
			myjpeg_array[0]=$jpgfname ;
			arrayindex=1 ;
                        loop="no" ;
                        let endepoch=$myepoch+2 ;
                        let startepoch=$myepoch+1 ;
                        seq_epoch=$startepoch ;
                        jpegloop="yes" ;

                        # the below loop will pick up the rest of the snapshots
                        # in sequence.  myjpegs was already populated with the
                        # trigger above.
                        while [ $jpegloop == "yes" ] ;
                        do
                                jseqnum=$( echo $seq_epoch | awk '{print strftime("%Y%m%d_%H%M%S",$1) }'  ) ;
                                jpgfname="$SNAPSDIR/${jseqnum}.jpg" ;
                                if [  -e $jpgfname ] ; then # it's a hit
                                        myjpegs="$myjpegs $jpgfname" ;
					myjpeg_array[$arrayindex]=$jpgfname ;
					let arrayindex=$arrayindex+1 ;
                                else jpegloop="no" ; # it's not a hit let's get out of here
                                fi
                                let seq_epoch=$seq_epoch+1 ;
                        done
                fi     
                let myepoch=$myepoch+1 ; # get the next second
                let found=$found+1 ;

		# protect against infinite loops
                if [ $found -gt 9 ] ; then myjpegs="" ; loop="no" ; fi

        done # end of loop=yes

	# we don't want to go further if instance corrupt
	if [ -z "$myjpegs"  ] ; then

		# $file is a .mp4 file in the day dir
		# since there are no snapshots we can't detect an
		# approach so we log it and move it to a corrupt directory.
		# which can be deleted later.
		echo "$LOGTEXT corrupt $file  ... skipping compares" >> $LOG ; 
#		echo "mv -n $file $CORRUPTDIR" | tee -a "$CORRUPT"  ;
		mv    $mp4file $CORRUPTDIR   ;
		echo "$LOGTEXT jpegs for mp4 file $file not found" ;
		continue ;
	fi

if [ $debug -eq 1 ] ; then echo "myjpegs $myjpegs 0 ${myjpeg_array[0]} 1 ${myjpeg_array[1]} 2 ${myjpeg_array[2]}" ; fi

	# heavy processing below
#	# the first three trigger snapshots are evaluated

	for (( c=0 ; c<=2 ; c++ )) ;
	do
		let lindex=$nozeros+$c ;
		myindex=$(printf "%06d" $lindex) ;
		mynum=${seqdate}-${myindex} ;
		myfile=${myjpeg_array[$c]} ;

		# let's make the picture arrays
		# first make their directories, one for each instance
	
		idir=$ADIR/$global_mynum ;
		if [ ! -d $ADIR/$global_mynum ] ; then
			echo "$mydate mkdir $ADIR/$global_mynum " >> $LOG ;
			mkdir $ADIR/$global_mynum ;
		fi
		if [ $c -eq 0 ] ; then
			ndir="$NADIR/N" ;  # this dir should already exist
			if [ ! -d $ndir ] ; then mkdir $ndir ; fi
			sdir=$ndir ;
		elif [ $c -eq 1 ] ; then
			n1dir="$NADIR/N1" ;
			if [ ! -d $n1dir ] ; then mkdir $n1dir ; fi
			sdir=$n1dir ;
		elif [ $c -eq 2 ] ; then
			n2dir="$NADIR/N2" ;
			if [ ! -d $n2dir ] ; then mkdir $n2dir ; fi
			sdir=$n2dir ;
		else echo "shouldn't get here c is $c" ; exit ; 
		fi

		if [ ! -e $idir/n1.dat ]  ; then  
			# conversion not done else skip

			# defined at beginning of script
			# SECTION_RES="128x72" ; # this is default 1280x720
			# now that the dir exists we can make the arrays
			convert $myfile -crop $SECTION_RES  +repage  +adjoin  $sdir/schmoo_%03d.jpg
		else echo "$LOGTEXT $idir/n1.dat exists ... skipping conversion" ;
		fi
	done # end of  for (( c=0 ; c<=2 ; c++ )) cycling through 3 snapshots

	# all schmoo photos finished for this video instance
	# let's make our two comparisons,
	# n to n+1 and n+1 to n+2
	# these will go in directories n1 and n2
	# time n is the trigger photo

	n2data=$idir/n2.dat ;
	n1data=$idir/n1.dat ;

	if [ ! -e $n1data ] || [ ! -e $n2data ] ; then
		if [ -e $n2data ] ; then rm $n2data ; fi
		if [ -e $n1data ] ; then rm $n1data ; fi
	else continue ; # if they both exist let's skip
	fi
#---------next 3 for next nested loops not tabbed for readability

	# these next loops will set up and run the 
	# ImageMagick command "compare" which will generate
	# a bunch of numbers placed in files:
	#
	# n1.dat n2.dat n1_visual.dat n2_visual.dat
	# 
	# the *visual.dat are for quick debugging.
	# the former 2 files are used in the perl script 
	# showdata.pl to determine whether or not to kick 
	# the mp4 as a non-approach.

	# the images used are the 10x10 images
	# separated using the convert command above.
	
	# a loop handles n type comparisons
	for (( a=1 ; a<=2 ; a++ ))
	do
		addthis="" ;
		ndata="$idir/n${a}${addthis}.dat" ;
		visdata="$idir/n${a}${addthis}_visual.dat" ;
		if [ -e $ndata ] && [ $force -eq 0 ] ; then
			echo "$LOGTEXT $ndata exists let's get out of here" ;
			break ;
		elif [ $force -eq 1 ] ; then
			rm $ndata ;
		fi
		if [ -e $visdata ] ; then rm $visdata ; fi
	# b and c loops are indexed row/column for the image
	for (( b=0 ; b<=9 ; b++ ))  # row
	do
	for (( c=0 ; c<=9 ; c++ )) # column
	do
		aindex="0${b}${c}" ; 
#echo "aindex is $aindex" ; exit ;
#		pindex=$(printf "%03d" $aindex ) ;
		pindex=$aindex ;
		if [ $a -eq 1 ] ; then
#			echo "comparing N <-> N1  $file1 $file2" ;
			file1=$ndir/schmoo_${pindex}.jpg
			file2=$n1dir/schmoo_${pindex}.jpg
		else
#			echo "comparing N1 <-> N2  $file1 $file2" ;
			file1=$n1dir/schmoo_${pindex}.jpg
			file2=$n2dir/schmoo_${pindex}.jpg
		fi
		if [ ! -e $file1 ] || [ ! -e $file2 ] ; then
			echo "no $file1 or $file2" ;  exit ;
		fi
#		echo "compare -metric MAE $file1 $file2  null: 2>&1" ;
		mycmp=$(compare -metric MAE $file1 $file2  null: 2>&1 ) ;
#		mycmp=$(compare -metric MAE $file1 $file2  null: 2> /dev/null ) ;
		
		# the visual file uses an integer
		mycmp1=$( echo $mycmp | awk '{print $1}' )   ;
		mycmp1_int=${mycmp1/\.*} ;
		
		printf "%s %s\n" $pindex "$mycmp" >> $ndata ;
		printf "%05d " "$mycmp1_int" >> $visdata ;
	done # cloop
	printf "\n" >> $visdata ;
	done # bloop
	done # aloop
#	exit ;
   done # endof file in *.mp4 ( inner loop )

#exit ;

# The inner loop processing a single day directory has completed
# we now process the results of that by running showdata.sh
# a bash script located in a bin directory somewhere
# defined below

# let's run showdata and reduce $dirname automatically
	echo "$LOGTEXT the end --- $daydir" | tee -a $LOG  ;
	dayname=$( basename $daydir ) ;

	showdata_fh="$C6/mkarray4.dat" ;

	$SHOWDATA  $daydir  > $showdata_fh ;

#echo "$LOGTEXT break $showdata_fh written" ; exit ;

	echo "$LOGTEXT start $dayname = $dirwc" | tee -a $LOG  ;
	ndirwc=$(grep ^kicked $showdata_fh  | wc| awk '{print $1}') ;
	echo "$LOGTEXT kicked $dayname = $ndirwc" | tee -a $LOG  ;

	echo "check numbers by using the following"  | tee -a $LOG ;
	echo "$LOGTEXT $SHOWDATA show $showdata_fh"  | tee -a $LOG ;
	echo "$LOGTEXT ------------------------"  | tee -a $LOG ;
	echo " To move files to kicked" | tee -a $LOG 

	# EXTHIS is an executable script that moves kicked data
	# into the kicked directory for ultimate deletion by another
	# process.
	EXTHIS="$BASE/camera6/mvkicked_${dayname}.sh" ;

	grep ^mv $showdata_fh >> $EXTHIS ;
	chmod +x $EXTHIS ;
	echo "${EXTHIS}"  | tee -a $LOG ;

	# the process.sh script takes a simple filename without directory
	# it was simpler to not fix this in process.sh and just send
	# that script the base filenmae of the move kicked script

	process_file=$EXTHIS ;
	echo "$LOGTEXT running process.sh $process_file" | tee -a  $LOG ;
	$BASE/camera6/bin/process.sh $process_file ;

	echo "$LOGTEXT ----the end $dayname" | tee -a $LOG  ;

done ; # endof daydirs loop == no indentation

echo "$LOGTEXT all done" ;

exit ;

